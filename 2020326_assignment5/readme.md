OS assignment 5:

Question 1:

input format:
    after running make command, we have to run ./q1

output format:
    the file will periodically print which philosopher is feeling hungry, which philosopher has finished eating, and which philosopher is currently eating with which forks, and how many times a philosopher has eaten.

explanation:
    we have statically declared 6 semaphores, and we have also declared a char array which will store whether a philosopher is hungry, eating or if he is thinking after finishing eating. we have also created an array that keeps track of how many times a philosopher has already eaten. we have also kept an array that has the numbers of every philosopher. we have also created two functions, one that will find the index to the right of the given philosopher, and the other will give us the index to the left of the philosopher.
    in the main function, we initialize these arrays. we give values to the semaphores( the first semaphore is a counting semaphore with a value of 5, while the rest of the philosophers are binary semaphores and are initialized with a value of 0). after that we use pthread_create() function to create 5 threads. one for each philosopher, and we pass the philosophers id as an argument. finally we use pthread_join() to join the 5 threads back into the main thread.
    we pass each thread to the philosopher_i function, which is a void* type function. after that in the function, we first convert the void*i integer passed as an argument to an integer k. after that we have the processes sleep for 1 second, and then use sem_wait to make sure that the counting semaphore we have created has a value greater than 0. Otherwise, sem_wait makes the process pause until it has a value greater than 0. then we make the current philosopher hungry, and then we check whether he is hungry, and whether the philosophers next to him are eating or not. if they are eating, it means that they are using the forks, because of which the current philosopher cannot use the forks to eat, and has to wait. if the philosopher can eat, we change his status to eating, so that the philosophers adjacent to him cannot eat. we then have the program sleep for a second to make sure that no other philosopher also picked up his fork at the same time. then we call sem_post() on the binary semaphore to increase its value. after that when he is done eating, we call sem_post() on the counting semaphore, and sem_wait() on the binary semaphore. in this way, we have reset the semaphores if he had eaten. In case he had not eaten, it means that the either he was not hungry or that the philosophers adjacent to him were eating at the moment. in the function only, after sem_wait(), we call sleep function and then we call sem_wait on the counting semaphore. then we set the status of the philosopher to thinking. this signifies that the philosopher is done eating and is now thinking and waiting before eating again. putting philosopher in thinking state prevents the philosophers from eating too quickly. now that we have stopped this philosopher from eating, we check if the philosophers adjacent to him are hungry. if they are, we set their status to eating and then we let the program sleep for 1 second, and then we similarly call sem_post(). we do this with both the philosopher's to his either side. we finally call sem_post on the counting semaphore. finally, the do-while loop starts over again, and the same process is repeated until we press ctrl^c.
    this is a deadlock free solution, and it makes sure that all the philosophers can keep eating.

assumptions:
    we are assuming that user will have run make command before running the program

Question 2:

Explanation:
    In part 2, there will no deadlock. this is because each philosopher only need one fork to eat. therefore, in this situation, in the worst case, let us consider philosopher number 1. let us assume that the philosophers adjacent to him will take forks to his left and right. because of this, philosopher number 1 will not be able to eat but number 5 and 2 will be able to eat. now number 3 and 4 will also have 3 forks total. because of this, in the worst case, 4 philosophers will be able to eat. in the best case, all 5 philosophers will pick the fork to their left. as there are 4 bowls, if 4 people manage to pick up forks, all 4 people will be able to eat, whereas if 5 people are able to pick up the forks, only 4 people will be able to eat. thus, as multiple people will always be able to eat, we can see that a deadlock will never occur. there will never be a situation where no philosopher can be able to eat. there are more than enough resources for every philosopher to eat and a deadlock will never occur.

Question 3:

input format:
    after running make command, we have to run ./q3

output format:
    the file will periodically print which philosopher is feeling hungry, which philosopher has finished eating, and which philosopher is currently eating with which forks and which bowl, and how many times a philosopher has eaten.

explanation:
    we have statically declared 6 semaphores, and we have also declared a char array which will store whether a philosopher is hungry, eating or if he is thinking after finishing eating. we have also created an array that keeps track of how many times a philosopher has already eaten. we have also kept an array that has the numbers of every philosopher. we have also declared a char array of size 4 that tells us if a bowl is vacant or being eaten with. we have also created an integer array of size 4, that tells us who is currently eating from a particular bowl. we have also created two functions, one that will find the index to the right of the given philosopher, and the other will give us the index to the left of the philosopher. we have also created a function, that will tell us the index of the first vacant bowl, and a function that will give us the index of the bowl being used by a particular philosopher.
    in the main function, we initialize these arrays. we give values to the semaphores( the first semaphore is a counting semaphore with a value of 4(as there are 4 bowls), while the rest of the philosophers are binary semaphores and are initialised with a value of 0). after that we use pthread_create() function to create 5 threads. one for each philosopher, and we pass the philosophers id as an argument. finally we use pthread_join() to join the 5 threads back into the main thread.
    we pass each thread to the philosopher_i function, which is a void* type function. after that in the function, we first convert the void*i integer passed as an argument to an integer k. after that we have the processes sleep for 1 second, and then use sem_wait to make sure that the counting semaphore we have created doesn't has a value greater than 0. if it does, sem_wait() makes the process pause until it has a value greater than 0. then we make the current philosopher hungry, and then we check whether he is hungry, and whether the philosophers next to him are eating or not, and if there are any free bowls. if they are eating, it means that they are using the forks, or that there are no free bowls, because of which the current philosopher cannot use the fork to eat, and has to wait. if the philosopher can eat, we change his status to eating, and mark the respective bowl as being used, so that the philosophers at his sides cannot eat. we then have the program sleep for a second to make sure that no other philosopher also picked up his fork at the same time. then we call sem_post() on the binary semaphore to increase its value. after that when he is done eating, we call sem_post() on the counting semaphore, and sem_wait on the binary semaphore. in this way, we have reset the semaphores if he had eaten. In case he had not eaten, it means that the either he was not hungry or that the philosophers adjacent to him were eating at the moment. in the function only, after sem_wait(), we call sleep function and then we call sem_wait on the counting semaphore. then we set the status of the philosopher to thinking, and if the philosopher was using any bowls, we set their status as vacant. this signifies that the philosopher is done eating and is now thinking and waiting before eating again. putting philosopher in thinking state prevents the philosophers from eating too quickly. now that we have stopped this philosopher from eating, we check if the philosophers adjacent to him are hungry. if they are, we set their status to eating, and set status of bowl as being eaten with and then we let the program sleep for 1 second, and then we similarly call sem_post. we do this with both the philosopher's to his either side. we finally call sem_post on the counting semaphore. finally, the do-while loop starts over again, and the same process is repeated until we press ctrl^c.
    this is a deadlock free solution, and it makes sure that all the philosophers can keep eating.

assumptions:
    we are assuming that user will have run the make command before running the program,
